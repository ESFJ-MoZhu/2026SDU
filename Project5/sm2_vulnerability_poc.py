"""
SM2签名算法误用的POC验证代码
包含常见的签名算法误用场景和攻击演示
作者: ESFJ-MoZhu
日期: 2025-07-20
"""
import hashlib
import random
from sm2_base import SM2, Point
from typing import List, Tuple
class SM2VulnerabilityPOC(SM2):
    """SM2签名算法漏洞概念验证类"""
    def __init__(self):
        super().__init__()
        self.attack_results = []
    def poc_nonce_reuse_attack(self) -> dict:
        """POC 1: 随机数k重用攻击演示"""
        print("=== POC 1: 随机数k重用攻击 ===")
        # 生成密钥对
        private_key, public_key = self.generate_keypair()
        # 准备两个不同的消息
        message1 = b"Hello, World!"
        message2 = b"Attack Vector!"
        # 故意使用相同的k值进行签名
        k_fixed = random.randint(1, self.n - 1)
        # 修改签名函数以使用固定的k
        def sign_with_fixed_k(message: bytes, k: int) -> Tuple[int, int]:
            e = int.from_bytes(self.sm3_hash(message), 'big')
            point = self.point_multiply(k, self.G)
            x1 = point.x
            r = (e + x1) % self.n
            if r == 0 or r + k == self.n:
                return None, None
            d_inv = self.mod_inverse(1 + private_key, self.n)
            s = (d_inv * (k - r * private_key)) % self.n
            if s == 0:
                return None, None
            return r, s
        # 对两个消息使用相同的k进行签名
        r1, s1 = sign_with_fixed_k(message1, k_fixed)
        r2, s2 = sign_with_fixed_k(message2, k_fixed)
        if r1 is None or r2 is None:
            return {"success": False, "reason": "签名生成失败"}
        # 攻击：从两个签名中恢复私钥
        e1 = int.from_bytes(self.sm3_hash(message1), 'big')
        e2 = int.from_bytes(self.sm3_hash(message2), 'big')
        # 计算 k = (s1 - s2)^(-1) * (e1 - e2) mod n
        try:
            s_diff_inv = self.mod_inverse((s1 - s2) % self.n, self.n)
            k_recovered = (s_diff_inv * (e1 - e2)) % self.n
            # 验证恢复的k是否正确
            if k_recovered == k_fixed:
                # 使用恢复的k计算私钥
                # d = (s1 * k - e1 - r1) * (r1)^(-1) mod n
                r1_inv = self.mod_inverse(r1, self.n)
                d_recovered = ((s1 * k_recovered - e1 - r1) * r1_inv) % self.n
                result = {
                    "success": True,
                    "original_private_key": private_key,
                    "recovered_private_key": d_recovered,
                    "k_original": k_fixed,
                    "k_recovered": k_recovered,
                    "attack_successful": d_recovered == private_key
                }
            else:
                result = {"success": False, "reason": "k恢复失败"}
        except:
            result = {"success": False, "reason": "模逆计算失败"}
        self.attack_results.append(("nonce_reuse", result))
        return result
    def poc_weak_randomness_attack(self) -> dict:
        """POC 2: 弱随机数攻击演示"""
        print("=== POC 2: 弱随机数攻击 ===")
        # 模拟弱随机数生成器（可预测的k值）
        weak_seed = 12345
        random.seed(weak_seed)
        private_key, public_key = self.generate_keypair()
        message = b"Weak randomness test"
        # 使用弱随机数生成k
        weak_k = random.randint(1, self.n - 1)
        # 重置随机数种子，模拟攻击者也能生成相同的k
        random.seed(weak_seed)
        predicted_k = random.randint(1, self.n - 1)
        # 生成签名
        r, s = self.sign(message, private_key)
        result = {
            "success": True,
            "weak_k": weak_k,
            "predicted_k": predicted_k,
            "k_prediction_successful": weak_k == predicted_k,
            "vulnerability": "攻击者可以预测随机数k，从而恢复私钥"
        }
        self.attack_results.append(("weak_randomness", result))
        return result
    def poc_signature_malleability(self) -> dict:
        """POC 3: 签名可塑性攻击演示"""
        print("=== POC 3: 签名可塑性攻击 ===")
        private_key, public_key = self.generate_keypair()
        message = b"Malleability test"
        # 生成原始签名
        r, s = self.sign(message, private_key)
        # 创建可塑的签名：s' = n - s
        s_malleable = self.n - s
        # 验证原始签名和可塑签名
        original_valid = self.verify(message, (r, s), public_key)
        malleable_valid = self.verify(message, (r, s_malleable), public_key)
        result = {
            "success": True,
            "original_signature": (r, s),
            "malleable_signature": (r, s_malleable),
            "original_valid": original_valid,
            "malleable_valid": malleable_valid,
            "vulnerability": "攻击者可以在不知道私钥的情况下创建不同但有效的签名"
        }
        self.attack_results.append(("signature_malleability", result))
        return result
    def poc_hash_collision_attack(self) -> dict:
        """POC 4: 哈希碰撞攻击模拟"""
        print("=== POC 4: 哈希碰撞攻击模拟 ===")
        private_key, public_key = self.generate_keypair()
        # 模拟找到哈希碰撞的两个消息
        # 实际中这需要巨大的计算量，这里只是演示概念
        message1 = b"Original message"
        message2 = b"Colliding message"  # 假设这两个消息有相同的哈希
        # 为了演示，我们人为创建"碰撞"
        original_hash = self.sm3_hash(message1)
        # 对第一个消息签名
        signature = self.sign(message1, private_key)
        # 验证签名对两个消息都有效（在真实碰撞情况下）
        verify1 = self.verify(message1, signature, public_key)
        verify2 = self.verify(message2, signature, public_key)
        result = {
            "success": True,
            "message1": message1,
            "message2": message2,
            "signature": signature,
            "message1_valid": verify1,
            "message2_valid": verify2,
            "vulnerability": "如果找到哈希碰撞，同一个签名可以验证不同的消息"
        }
        self.attack_results.append(("hash_collision", result))
        return result
    def poc_public_key_recovery(self) -> dict:
        """POC 5: 从签名恢复公钥演示"""
        print("=== POC 5: 从签名恢复公钥 ===")
        private_key, public_key = self.generate_keypair()
        message = b"Public key recovery test"
        # 生成签名
        r, s = self.sign(message, private_key)
        e = int.from_bytes(self.sm3_hash(message), 'big')
        # 尝试恢复公钥
        # 公钥 P = r^(-1) * (s * R - e * G)，其中R是椭圆曲线上x坐标为r的点
        try:
            # 找到x坐标为r的点R（可能有两个y坐标）
            y_squared = (pow(r, 3, self.p) + self.a * r + self.b) % self.p
            y = pow(y_squared, (self.p + 1) // 4, self.p)  # 简化的平方根计算
            R1 = Point(r, y)
            R2 = Point(r, self.p - y)
            r_inv = self.mod_inverse(r, self.n)
            # 尝试两个可能的R点
            for R in [R1, R2]:
                sR = self.point_multiply(s, R)
                eG = self.point_multiply(e, self.G)
                # P = r^(-1) * (s * R - e * G)
                diff = self.point_add(sR, Point(eG.x, self.p - eG.y))  # sR - eG
                recovered_public_key = self.point_multiply(r_inv, diff)
                if recovered_public_key == public_key:
                    result = {
                        "success": True,
                        "original_public_key": (public_key.x, public_key.y),
                        "recovered_public_key": (recovered_public_key.x, recovered_public_key.y),
                        "recovery_successful": True,
                        "vulnerability": "在某些情况下可以从签名中恢复公钥"
                    }
                    self.attack_results.append(("public_key_recovery", result))
                    return result
            result = {
                "success": False,
                "reason": "公钥恢复失败",
                "vulnerability": "公钥恢复在某些参数下可能失败"
            }
        except Exception as e:
            result = {
                "success": False,
                "reason": f"计算错误: {str(e)}",
                "vulnerability": "数学计算复杂性"
            }
        self.attack_results.append(("public_key_recovery", result))
        return result
    def run_all_pocs(self) -> dict:
        """运行所有POC测试"""
        print("开始运行SM2签名算法误用POC验证...")
        print("=" * 50)
        results = {}
        results["nonce_reuse"] = self.poc_nonce_reuse_attack()
        print()
        results["weak_randomness"] = self.poc_weak_randomness_attack()
        print()
        results["signature_malleability"] = self.poc_signature_malleability()
        print()
        results["hash_collision"] = self.poc_hash_collision_attack()
        print()
        results["public_key_recovery"] = self.poc_public_key_recovery()
        print()
        print("=" * 50)
        print("所有POC测试完成")
        return results
    def generate_vulnerability_report(self) -> str:
        """生成漏洞分析报告"""
        report = """
# SM2签名算法误用漏洞分析报告
## 1. 随机数k重用攻击
**风险等级**: 极高
**描述**: 当使用相同的随机数k对不同消息进行签名时，攻击者可以通过数学计算恢复私钥。
**影响**: 完全破坏密钥安全性
**防护措施**: 
- 确保每次签名使用强随机数生成器
- 实施确定性签名方案(RFC 6979)
## 2. 弱随机数攻击
**风险等级**: 高
**描述**: 使用可预测的随机数生成器会导致私钥泄露。
**影响**: 攻击者可以预测并重现签名过程
**防护措施**:
- 使用密码学安全的随机数生成器
- 定期检查随机数质量
## 3. 签名可塑性
**风险等级**: 中
**描述**: 在不知道私钥的情况下，可以创建不同但同样有效的签名。
**影响**: 可能导致重放攻击或交易篡改
**防护措施**:
- 实施签名规范化
- 在协议层面检查签名唯一性
## 4. 哈希碰撞攻击
**风险等级**: 中
**描述**: 如果哈希函数存在碰撞，同一签名可验证不同消息。
**影响**: 消息完整性受损
**防护措施**:
- 使用抗碰撞的哈希函数
- 定期更新哈希算法
## 5. 公钥恢复
**风险等级**: 低
**描述**: 在某些情况下可以从签名中恢复公钥。
**影响**: 隐私泄露，但不直接影响安全性
**防护措施**:
- 如需要隐私保护，使用额外的混淆技术
## 总结
SM2算法本身是安全的，但实现时必须注意避免这些常见陷阱。
最关键的是确保随机数生成的质量和唯一性。
        """
        return report
# 使用示例
if __name__ == "__main__":
    poc = SM2VulnerabilityPOC()
    results = poc.run_all_pocs()
    print("\n" + "="*50)
    print("POC测试结果摘要:")
    for test_name, result in results.items():
        print(f"{test_name}: {'成功' if result['success'] else '失败'}")
    print("\n生成漏洞报告...")
    report = poc.generate_vulnerability_report()
    print(report)